#pragma once
#include <Windows.h>
#include <vector>
#include <string>
#include "nlohmann/json.hpp"
#include "LinkedList.h"
#include "eventdef.h"
#include "helper.h"

using namespace nlohmann;




namespace eventparser
{
	EventType CheckType(PlEntry* Event);
	json EventToJson(PlEntry* Event);							// We will take in the first elment of an Event struct template and parse it from here
	json ParseFileParseEvent(Event<FileParseEvent>* fileEvent);
	json ParseFileEvent(Event<FileEvent>* fileEvent);
	json ParseNetworkEvent(Event<NetworkEvent>* networkEvent);
	json ParseProcessEvent(Event<ProcessEvent>* processEvent);
	json ParseImageLoadEvent(Event<ImageLoadEvent>* imageLoadEvent);
	json ParseThreadEvent(Event<ThreadEvent>* threadEvent);
	json ParseRemoteThreadEvent(Event<RemoteThreadEvent>* remoteThreadEvent);
	json ParseRegistryEvent(Event<RegistryEvent>* registryEvent);
	json ParseObjectCallbackEvent(Event<ObjectCallbackEvent>* objectCallbackEvent);
}



class manager
{
public:
	manager();
	~manager();

	PListHeader EventHead;
	std::vector<DWORD> Errors;

private:
	static void DriverEventConsumerThread();						// THIS THREAD WILL CONSUME EVENTS GENERATED BY THE DRIVER AND ADD TO EventHead
	static void API_sendThread();									// THIS THREAD WILL PARSE EVENTS ADDED TO EventHead AND SEND THEM TO THE SERVER IN JSON FORMAT
	static void API_recvThread();									// THIS THREAD WILL LISTEN AND HANDLE COMMANDS INCOMING FROM THE SERVER

	void ConsumeErrors(std::vector<DWORD>& ErrorVector);	
private:
	// THE ORIGINAL FILE THAT WE WANTED TO EXAMINE
	static std::string MonitoredFilePath;							
	
	// THIS WILL HOLD ALL EVENTS TO BE SENT TO THE SERVER
	

	// ERRORS
	

	// MUTEXES
	static HANDLE EventHeadMutex;
	static HANDLE ErrorsMutex;

	// THREAD HANDLES
	HANDLE hDriverEventConsumerThread;
	HANDLE hAPI_sendThread;
	HANDLE hAPI_recvThread;
};

