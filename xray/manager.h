#pragma once




#include <winsock2.h>
#include <WS2tcpip.h>
#include <Windows.h>


#include <vector>
#include <string>
#include "nlohmann/json.hpp"
#include <shlobj.h>
#include "LinkedList.h"
#include "eventdef.h"
#include "api_status.h"
#include "helper.h"


#pragma comment (lib, "Ws2_32.lib")


using namespace nlohmann;




namespace eventparser
{
	EventType CheckType(PlEntry* Event);
	json EventToJson(PlEntry* Event);							// We will take in the first elment of an Event struct template and parse it from here
	json ParseFileParseEvent(Event<FileParseEvent>* fileEvent);
	json ParseFileEvent(Event<FileEvent>* fileEvent);
	json ParseNetworkEvent(Event<NetworkEvent>* networkEvent);
	json ParseProcessEvent(Event<ProcessEvent>* processEvent);
	json ParseImageLoadEvent(Event<ImageLoadEvent>* imageLoadEvent);
	json ParseThreadEvent(Event<ThreadEvent>* threadEvent);
	json ParseRemoteThreadEvent(Event<RemoteThreadEvent>* remoteThreadEvent);
	json ParseRegistryEvent(Event<RegistryEvent>* registryEvent);
	json ParseObjectCallbackEvent(Event<ObjectCallbackEvent>* objectCallbackEvent);
};







class manager
{
public:
	manager(char* _Server);
	~manager();
	void Stop();
	BOOL CheckExit();
	std::string Server;
	std::vector<DWORD> Errors;
	std::string MonitoredFilePath;
private:
	

	void ConsumeErrors(std::vector<DWORD>& ErrorVector);	
private:
	BOOL exit;

	// ERRORS
	

	// MUTEXES
	HANDLE EventHeadMutex;
	HANDLE ErrorsMutex;

	// THREAD HANDLES
	HANDLE hDriverEventConsumerThread;
	HANDLE hAPI_sendThread;
	HANDLE hAPI_recvThread;
};

struct CommandHandler_Info
{
	int connection_sock_fd;
	manager* mgr;
	BYTE* commBuf;
};



void DriverEventConsumerThread(manager* mgr);						// THIS THREAD WILL CONSUME EVENTS GENERATED BY THE DRIVER AND ADD TO EventHead
void API_sendThread(manager* mgr);									// THIS THREAD WILL PARSE EVENTS ADDED TO EventHead AND SEND THEM TO THE SERVER IN JSON FORMAT
void API_recvThread(manager* mgr);									// THIS THREAD WILL LISTEN AND HANDLE COMMANDS INCOMING FROM THE SERVER
void CommandHandler(CommandHandler_Info* _CommandHandlerInfo);

